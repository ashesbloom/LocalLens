name: Windows Release Build

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        default: 'v1.0.0'

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  # Tauri updater signing key (set in GitHub Secrets)
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      # Backend: Create virtual environment and install requirements
      - name: Create Python virtual environment
        run: |
          cd backend
          python -m venv venv

      - name: Activate venv and install backend requirements
        run: |
          cd backend
          .\venv\Scripts\activate
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      # Backend: Build with PyInstaller using your spec file
      - name: Build Python backend with PyInstaller
        run: |
          cd backend
          .\venv\Scripts\activate
          python -m PyInstaller backend_server.spec

      # Frontend: Install requirements in src-tauri folder
      - name: Install frontend requirements
        run: |
          cd frontend
          npm install

      - name: Install Tauri requirements
        run: |
          cd frontend/src-tauri
          # Install any additional Tauri-specific requirements if needed
          # Currently using npm install from frontend folder covers this

      # Copy the exact file you get from PyInstaller to src-tauri
      - name: Copy backend executable to Tauri
        run: |
          copy backend\dist\backend_server-x86_64-pc-windows-msvc.exe frontend\src-tauri\

      # Build the final application with signing enabled
      - name: Build Tauri application
        run: |
          cd frontend
          npm run tauri build

      # Generate checksums for verification
      - name: Generate checksums
        run: |
          cd frontend\src-tauri\target\release\bundle
          $files = Get-ChildItem -Recurse -Include "*.msi", "*.exe" | Where-Object { $_.Directory.Name -eq "msi" -or $_.Directory.Name -eq "nsis" }
          $checksums = @()
          foreach ($file in $files) {
            $hash = Get-FileHash -Path $file.FullName -Algorithm SHA256
            $checksums += "$($hash.Hash.ToLower())  $($file.Name)"
          }
          $checksums | Out-File -FilePath "checksums-windows.txt" -Encoding utf8
          Write-Output "Generated checksums:"
          Get-Content "checksums-windows.txt"

      # Find the generated installer files and signature
      - name: Find installer files
        id: find_files
        run: |
          cd frontend\src-tauri\target\release\bundle
          
          $msiFile = Get-ChildItem -Path "msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Select-Object -First 1
          $msiSigFile = Get-ChildItem -Path "msi" -Filter "*.msi.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
          $exeFile = Get-ChildItem -Path "nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch "\.sig$" } | Select-Object -First 1
          $exeSigFile = Get-ChildItem -Path "nsis" -Filter "*.exe.sig" -ErrorAction SilentlyContinue | Select-Object -First 1
          
          if ($msiFile) {
            $msiPath = $msiFile.FullName
            echo "msi_path=$msiPath" >> $env:GITHUB_OUTPUT
            echo "msi_name=$($msiFile.Name)" >> $env:GITHUB_OUTPUT
            Write-Output "Found MSI: $msiPath"
          }
          if ($msiSigFile) {
            $msiSigPath = $msiSigFile.FullName
            $msiSignature = Get-Content $msiSigPath -Raw
            echo "msi_sig_path=$msiSigPath" >> $env:GITHUB_OUTPUT
            echo "msi_signature=$msiSignature" >> $env:GITHUB_OUTPUT
            Write-Output "Found MSI signature: $msiSigPath"
          }
          if ($exeFile) {
            $exePath = $exeFile.FullName
            echo "exe_path=$exePath" >> $env:GITHUB_OUTPUT
            echo "exe_name=$($exeFile.Name)" >> $env:GITHUB_OUTPUT
            Write-Output "Found EXE: $exePath"
          }
          if ($exeSigFile) {
            $exeSigPath = $exeSigFile.FullName
            $exeSignature = Get-Content $exeSigPath -Raw
            echo "exe_sig_path=$exeSigPath" >> $env:GITHUB_OUTPUT
            echo "exe_signature=$exeSignature" >> $env:GITHUB_OUTPUT
            Write-Output "Found EXE signature: $exeSigPath"
          }
          
          $checksumPath = "checksums-windows.txt"
          if (Test-Path $checksumPath) {
            $fullChecksumPath = Resolve-Path $checksumPath
            echo "checksum_path=$fullChecksumPath" >> $env:GITHUB_OUTPUT
            Write-Output "Found checksums: $fullChecksumPath"
          }

      # Get version from tag
      - name: Get version
        id: get_version
        run: |
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace '^v', ''
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Version: $version"

      # Extract release notes from CHANGELOG.md
      - name: Extract release notes
        id: release_notes
        run: |
          $version = "${{ steps.get_version.outputs.version }}"
          $changelogPath = "CHANGELOG.md"
          
          if (Test-Path $changelogPath) {
            $content = Get-Content $changelogPath -Raw
            
            # Match the section for this version (## [X.Y.Z] until next ## [ or end)
            $pattern = "(?s)## \[$version\][^\r\n]*\r?\n(.*?)(?=\r?\n## \[|$)"
            $match = [regex]::Match($content, $pattern)
            
            if ($match.Success) {
              $notes = $match.Groups[1].Value.Trim()
              # Escape for GitHub Actions output
              $notes = $notes -replace '%', '%25'
              $notes = $notes -replace "`n", '%0A'
              $notes = $notes -replace "`r", '%0D'
              echo "notes=$notes" >> $env:GITHUB_OUTPUT
              Write-Output "Found release notes for version $version"
            } else {
              $defaultNotes = "Release $version - See CHANGELOG.md for details"
              echo "notes=$defaultNotes" >> $env:GITHUB_OUTPUT
              Write-Output "No specific notes found for $version, using default"
            }
          } else {
            $defaultNotes = "Release $version"
            echo "notes=$defaultNotes" >> $env:GITHUB_OUTPUT
            Write-Output "CHANGELOG.md not found, using default notes"
          }

      # Generate latest.json for Tauri updater
      - name: Generate latest.json
        id: generate_latest
        run: |
          $version = "${{ steps.get_version.outputs.version }}"
          $tag = "${{ github.ref_name }}"
          $msiSignature = "${{ steps.find_files.outputs.msi_signature }}"
          $repo = "${{ github.repository }}"
          $pubDate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
          
          # Get release notes (unescape the GitHub Actions encoding)
          $releaseNotes = "${{ steps.release_notes.outputs.notes }}"
          $releaseNotes = $releaseNotes -replace '%0A', "`n"
          $releaseNotes = $releaseNotes -replace '%0D', "`r"
          $releaseNotes = $releaseNotes -replace '%25', '%'
          
          # URL for the MSI installer (standard naming)
          $downloadUrl = "https://github.com/$repo/releases/download/$tag/Local_Lens_${tag}_x64_en-US.msi"
          
          $latestJson = @{
            version = $version
            notes = $releaseNotes
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                signature = $msiSignature.Trim()
                url = $downloadUrl
              }
            }
          } | ConvertTo-Json -Depth 4
          
          $latestJson | Out-File -FilePath "latest.json" -Encoding utf8
          Write-Output "Generated latest.json:"
          Get-Content "latest.json"
          
          $latestPath = Resolve-Path "latest.json"
          echo "latest_json_path=$latestPath" >> $env:GITHUB_OUTPUT

      # Create GitHub release
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Local Lens ${{ github.ref_name }}
          draft: true
          prerelease: false
          body: |
            ## Local Lens ${{ github.ref_name }}
            
            ${{ steps.release_notes.outputs.notes }}
            
            ---
            
            ### ðŸ”’ Security & Verification
            
            This Windows release was built automatically using GitHub Actions:
            
            - **Source Code**: Available in this repository at tag `${{ github.ref_name }}`
            - **Build Process**: View the complete build log in the [Actions tab](https://github.com/${{ github.repository }}/actions)
            - **Checksums**: SHA256 checksums provided below for file verification
            
            ### ðŸ“¥ Downloads
            
            Choose your preferred installer format:
            - **MSI Installer**: Recommended for enterprise/managed environments
            - **EXE Installer**: Recommended for individual users
            
            ### âœ… File Verification
            
            After downloading, verify file integrity:
            ```cmd
            certutil -hashfile "installer_name" SHA256
            ```
            Compare the output with the checksums in `checksums-windows.txt`.
            
            ### ðŸš€ Installation
            
            1. Download your preferred installer format
            2. Run the installer as Administrator (recommended)
            3. Follow the installation wizard
            4. Launch Local Lens from Start Menu or Desktop shortcut

      # Upload MSI installer
      - name: Upload MSI installer
        if: steps.find_files.outputs.msi_path
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.find_files.outputs.msi_path }}
          asset_name: Local_Lens_${{ github.ref_name }}_x64_en-US.msi
          asset_content_type: application/x-msi

      # Upload EXE installer
      - name: Upload EXE installer
        if: steps.find_files.outputs.exe_path
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.find_files.outputs.exe_path }}
          asset_name: Local_Lens_${{ github.ref_name }}_x64-setup.exe
          asset_content_type: application/x-msdownload

      # Upload checksums
      - name: Upload checksums
        if: steps.find_files.outputs.checksum_path
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.find_files.outputs.checksum_path }}
          asset_name: checksums-windows.txt
          asset_content_type: text/plain

      # Upload latest.json for Tauri auto-updater
      - name: Upload latest.json
        if: steps.generate_latest.outputs.latest_json_path
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.generate_latest.outputs.latest_json_path }}
          asset_name: latest.json
          asset_content_type: application/json

      # Print summary
      - name: Build Summary
        run: |
          Write-Output "âœ… Build completed successfully!"
          Write-Output "ðŸ“¦ Generated installers:"
          if ("${{ steps.find_files.outputs.msi_name }}" -ne "") {
            Write-Output "   - MSI: ${{ steps.find_files.outputs.msi_name }}"
          }
          if ("${{ steps.find_files.outputs.exe_name }}" -ne "") {
            Write-Output "   - EXE: ${{ steps.find_files.outputs.exe_name }}"
          }
          Write-Output "ðŸ“‹ Generated latest.json for auto-updater"
          Write-Output "ðŸ”’ Release created as draft - review and publish manually"
